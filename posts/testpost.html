<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Art of Rubber Duck Debugging - Mika Krooswijk</title>
    <style>
      body {
        max-width: 800px;
        margin: 40px auto;
        padding: 0 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          Arial, sans-serif;
        line-height: 1.6;
        color: #333;
      }
      h1 {
        color: #2c3e50;
        margin-bottom: 10px;
      }
      h2 {
        color: #34495e;
        margin-top: 30px;
      }
      time {
        color: #7f8c8d;
        font-size: 0.9em;
      }
      code {
        background-color: #f4f4f4;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: "Courier New", monospace;
        font-size: 0.9em;
      }
      pre {
        background-color: #f4f4f4;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
      }
      pre code {
        padding: 0;
        background: none;
      }
      a {
        color: #3498db;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      footer {
        margin-top: 50px;
        padding-top: 20px;
        border-top: 1px solid #eee;
      }
    </style>
  </head>
  <body>
    <article>
      <header>
        <h1>The Art of Rubber Duck Debugging</h1>
        <time datetime="2025-11-29">November 29, 2025</time>
      </header>

      <p>
        Every developer has been there: you're staring at your code, convinced
        there's a bug, but you can't figure out what's wrong. You've tried print
        statements, debuggers, and even rewriting sections from scratch. Then
        you explain the problem to a colleague, and halfway through your
        explanation, the solution hits you. This is the essence of rubber duck
        debugging.
      </p>

      <h2>What Is Rubber Duck Debugging?</h2>

      <p>
        Rubber duck debugging is a method where you explain your code
        line-by-line to an inanimate object‚Äîtraditionally a rubber duck. The act
        of articulating your logic forces you to slow down and examine
        assumptions you might have glossed over while coding in "flow state."
      </p>

      <p>
        The technique gets its name from a story in the book
        <em>The Pragmatic Programmer</em>
        where a programmer would carry around a rubber duck and debug their code
        by forcing themselves to explain it to the duck.
      </p>

      <h2>Why It Works</h2>

      <p>
        When you write code, you often operate on implicit assumptions. Your
        brain fills in gaps and makes logical leaps. But when you verbalize your
        code's logic, you're forced to:
      </p>

      <ul>
        <li>State explicit assumptions</li>
        <li>Follow the actual execution path rather than the intended one</li>
        <li>
          Notice discrepancies between what you think the code does and what it
          actually does
        </li>
        <li>Identify edge cases you hadn't considered</li>
      </ul>

      <h2>A Real Example</h2>

      <p>
        Let's say you're working on a function that filters a list of users by
        age:
      </p>

      <pre><code>function filterAdultUsers(users) {
    return users.filter(user => {
        if (user.age > 18) {
            return true;
        }
    });
}</code></pre>

      <p>
        You're getting unexpected results‚Äîsome 18-year-olds are being excluded.
        Let's rubber duck it:
      </p>

      <p>
        "Okay duck, this function takes a list of users. For each user, I check
        if their age is greater than 18. If it is, I include them..."
      </p>

      <p>
        Wait. Greater than 18? What about users who are <em>exactly</em> 18?
        They're adults too, but my condition excludes them. The bug is
        <code>&gt;</code> instead of <code>&gt;=</code>:
      </p>

      <pre><code>function filterAdultUsers(users) {
    return users.filter(user => {
        if (user.age >= 18) {
            return true;
        }
    });
}</code></pre>

      <p>Even better, we can simplify this to:</p>

      <pre><code>function filterAdultUsers(users) {
    return users.filter(user => user.age >= 18);
}</code></pre>

      <h2>When to Use It</h2>

      <p>Rubber duck debugging is particularly effective when:</p>

      <ul>
        <li>
          <strong>Logic bugs</strong>: Your code runs but produces wrong results
        </li>
        <li>
          <strong>Off-by-one errors</strong>: Loops or conditionals that are
          almost right
        </li>
        <li><strong>Null/undefined issues</strong>: Unexpected data states</li>
        <li>
          <strong>Complex conditionals</strong>: Nested if/else statements or
          boolean logic
        </li>
      </ul>

      <h2>Pro Tips</h2>

      <p>
        <strong>Talk out loud</strong>: Actually vocalize the explanation.
        Silent reading isn't as effective because your brain can still skip over
        details.
      </p>

      <p>
        <strong>Explain like you're teaching</strong>: Use the same detail you
        would if explaining to someone learning to code for the first time.
      </p>

      <p>
        <strong>Don't skip "obvious" parts</strong>: The bug often lurks in what
        seems obvious.
      </p>

      <p>
        <strong>Use a real duck (or any object)</strong>: Having a physical
        object to address makes the practice more tangible and less awkward than
        talking to thin air.
      </p>

      <h2>Beyond the Duck</h2>

      <p>
        While a rubber duck is the classic tool, any willing listener works‚Äîa
        colleague, a pet, or even a potted plant. The key is the act of
        externalization: moving the logic from your internal mental model into
        explicit, sequential statements.
      </p>

      <p>
        This technique extends beyond debugging too. Explaining your design
        decisions, architecture choices, or even your project roadmap to an
        inanimate object can help clarify your thinking and reveal gaps in your
        planning.
      </p>

      <h2>Conclusion</h2>

      <p>
        Rubber duck debugging might seem silly at first, but it's a powerful
        tool in any developer's toolkit. It costs nothing, works anywhere, and
        often solves problems faster than diving deep into debugger sessions.
        The next time you're stuck on a bug, grab a duck (or a coffee mug) and
        start explaining. You might be surprised how quickly the solution
        reveals itself.
      </p>

      <p>Happy debugging! ü¶Ü</p>

      <footer>
        <a href="/">‚Üê Back to home</a>
      </footer>
    </article>
  </body>
</html>
